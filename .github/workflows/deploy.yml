name: Build and Deploy to WSL

on:
  push:
    branches: [backend]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Build Frontend
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Node dependencies
        run: npm install

      - name: Update API URLs to local
        run: |
          chmod +x ./update-api-urls.sh
          ./update-api-urls.sh

      - name: Build frontend
        run: npm run build
        env:
          VITE_API_URL: "/api/v1" # Use local API path for production

      # Setup Go
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.22"

      # Build Go application for Linux (WSL) - with CGO enabled for SQLite
      - name: Build Go application
        run: |
          cd backend
          # Install SQLite development libraries
          sudo apt-get update && sudo apt-get install -y libsqlite3-dev
          # Build with CGO enabled for SQLite support
          GOOS=linux GOARCH=amd64 CGO_ENABLED=1 go build -o app
          # Verify it's a Linux binary
          file app
          # Check the binary size and permissions
          ls -la app

      # Copy frontend build to backend folder for deployment
      - name: Copy frontend to backend
        run: |
          mkdir -p backend/build
          cp -r dist/* backend/build/
          ls -la backend/build  # Verify the copy

      # Install necessary tools
      - name: Install SSH tools
        run: sudo apt-get install -y openssh-client sshpass

      # Deploy to Windows server using WSL
      - name: Deploy with WSL
        run: |
          echo "Attempting WSL deployment..."
          # Create SSH directory if it doesn't exist
          mkdir -p ~/.ssh
          # Disable StrictHostKeyChecking for this deployment
          echo "StrictHostKeyChecking no" > ~/.ssh/config

          # Check if WSL is installed
          echo "Checking WSL on server..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "powershell -Command \"if (!(Get-Command wsl -ErrorAction SilentlyContinue)) { Write-Error 'WSL not found, please install WSL on the Windows server'; exit 1 }\""

          # Create app directory in WSL (directly using root user for simplicity)
          echo "Creating deployment directory in WSL..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"mkdir -p /mnt/c/wsl-app\""

          # Copy build files to the server using SCP
          echo "Copying files to server..."
          # Create a deployment package
          tar -czf deployment.tar.gz -C backend . -C ../dist .
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} deployment.tar.gz ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\deployment.tar.gz"

          # Extract files in WSL
          echo "Extracting files in WSL..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"cd /mnt/c/wsl-app && tar -xzf deployment.tar.gz\""

          # List the extracted files to verify contents
          echo "Listing extracted files..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"ls -la /mnt/c/wsl-app\""

          # Check if app binary exists
          echo "Verifying app binary..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"if [ -f /mnt/c/wsl-app/app ]; then echo 'App binary exists'; else echo 'App binary NOT found!'; fi\""

          # Set executable permission on the app binary
          echo "Setting permissions..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"chmod +x /mnt/c/wsl-app/app\""

          # Stop any existing application
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"pkill -f /mnt/c/wsl-app/app || true\""

          # Install required libraries on WSL
          echo "Installing required libraries on WSL..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"apt-get update > /dev/null 2>&1 || true && apt-get install -y libsqlite3-0 > /dev/null 2>&1 || echo 'Failed to install libraries - may need root access'\""

          # Create a start script for the application
          echo "Creating start script..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo '#!/bin/bash' > /mnt/c/wsl-app/start.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'cd /mnt/c/wsl-app' >> /mnt/c/wsl-app/start.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'export PORT=8080' >> /mnt/c/wsl-app/start.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'export JWT_SECRET=test_secret' >> /mnt/c/wsl-app/start.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'nohup ./app > app.log 2>&1 &' >> /mnt/c/wsl-app/start.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"chmod +x /mnt/c/wsl-app/start.sh\""

          # Run the application
          echo "Starting application..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cd /mnt/c/wsl-app && ./start.sh\""
          
          # Give it a moment to start
          sleep 3
          
          # Create Windows scheduled task to start the app on boot (as a separate command)
          echo "Creating Windows scheduled task for autostart..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "powershell -Command \"Set-Content -Path 'C:\\wsl-app\\start-wsl-app.cmd' -Value 'wsl -d Ubuntu -e /mnt/c/wsl-app/start.sh'\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "powershell -Command \"\\$action = New-ScheduledTaskAction -Execute 'C:\\wsl-app\\start-wsl-app.cmd'; \\$trigger = New-ScheduledTaskTrigger -AtStartup; \\$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries; Register-ScheduledTask -TaskName 'Start WSL App' -Action \\$action -Trigger \\$trigger -Settings \\$settings -User SYSTEM -Force\""
          
          # Check if application is running
          echo "Checking application status with ps..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"ps aux | grep -v grep | grep app || echo 'Process not found with ps'\""

          # Check if application is running using PowerShell
          echo "Checking application status with PowerShell..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "powershell -Command \"try { Get-Process -Name app -ErrorAction Stop } catch { Write-Output 'WARNING: Application may not be running!' }\""

          # Check port status using simple cmd command
          echo "Checking if port 8080 is active..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "cmd /c \"netstat -an | findstr 8080\""

          # Create a diagnostic script
          echo "Creating diagnostic script..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo '#!/bin/bash' > /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'echo \"=== WSL Environment Variables ===\" > diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'env >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'echo \"=== Current Directory ===\" >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'pwd >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'echo \"=== Running Files ===\" >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'ls -la >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'echo \"=== Run App Directly ===\" >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'cd /mnt/c/wsl-app' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'export PORT=8080' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'export JWT_SECRET=your_secret_here' >> /mnt/c/wsl-app/diagnose.sh\""
          
          # Add library check and installation to diagnostic script
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'echo \"=== Checking and Installing Libraries ===\" >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'ldd ./app >> diagnostic.log 2>&1 || echo \"ldd failed - trying to install libraries\" >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'echo \"Installing SQLite library...\" >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'apt-get update >> /dev/null 2>&1 || echo \"apt-get update failed\" >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'apt-get install -y libsqlite3-0 >> /dev/null 2>&1 || echo \"apt-get install failed\" >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'ldd ./app >> diagnostic.log 2>&1 || echo \"ldd still failed after library installation\" >> diagnostic.log' >> /mnt/c/wsl-app/diagnose.sh\""
          
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo './app >> diagnostic.log 2>&1' >> /mnt/c/wsl-app/diagnose.sh\""

          # Make the diagnostic script executable
          echo "Making diagnostic script executable..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"chmod +x /mnt/c/wsl-app/diagnose.sh\""

          # Run the diagnostic script
          echo "Running diagnostics..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cd /mnt/c/wsl-app && ./diagnose.sh || echo 'Diagnostics failed' >> diagnostic.log\""

          # Display diagnostic logs
          echo "Diagnostic logs:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cat /mnt/c/wsl-app/diagnostic.log 2>/dev/null || echo 'No diagnostic log found'\""

          # Display application logs
          echo "Application logs:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cat /mnt/c/wsl-app/app.log 2>/dev/null || echo 'No app.log found'\""

          # Display exit code
          echo "Application exit code:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cat /mnt/c/wsl-app/exit_code.txt 2>/dev/null || echo 'No exit code file found'\""

          # Check for specific error messages in the logs
          echo "Checking for common errors in logs:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"grep -i 'error\\|fail\\|denied\\|permission' /mnt/c/wsl-app/app.log 2>/dev/null || echo 'No specific errors found in log'\""

          # Check file permissions
          echo "Checking file permissions:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"ls -la /mnt/c/wsl-app/\""
          
          # Check for shared library dependencies
          echo "Checking shared library dependencies:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"ldd /mnt/c/wsl-app/app || echo 'ldd command failed - binary may be statically linked'\""
          
          # Check if SQLite3 library is available
          echo "Checking if SQLite3 library is available:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"ldconfig -p | grep sqlite || echo 'SQLite library not found in cache'\""

          # Final check for debugging - directly check what happened
          echo "Direct WSL output for debugging:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"ls -la /mnt/c/wsl-app/ && echo '=== App Log Content ===' && cat /mnt/c/wsl-app/app.log 2>/dev/null || echo 'No app.log file found'\""

          # Check if there's an exit code file
          echo "Checking for exit code:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"if [ -f /mnt/c/wsl-app/exit_code.txt ]; then echo 'Exit code:' && cat /mnt/c/wsl-app/exit_code.txt; else echo 'No exit code file found'; fi\""

          # Try to identify what might be wrong with WSL 1
          echo "WSL version information:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --version || echo 'WSL version command not supported (likely WSL 1)'"

          # Check system info
          echo "System information:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"uname -a && cat /etc/os-release | grep PRETTY_NAME\""

      # Manual instructions if all else fails
      - name: Deployment failure instructions
        if: ${{ failure() }}
        run: |
          echo "Automated deployment failed. Please check the following:"
          echo "1. Make sure WSL is installed on the Windows server"
          echo "2. Make sure the SSH credentials are set in the GitHub secrets"
          echo "3. Check if port 8080 is available on the server"
          echo "4. You can manually deploy by following these steps:"
          echo "   a. Install WSL on your Windows server if not already installed"
          echo "   b. Create directory: mkdir -p C:\wsl-app"
          echo "   c. Copy the backend files to C:\wsl-app"
          echo "   d. Using WSL, make the binary executable: wsl --exec chmod +x /mnt/c/wsl-app/app"
          echo "   e. Run with: wsl --exec bash -c \"cd /mnt/c/wsl-app && export PORT=8080 && ./app\""
