name: Build and Deploy to WSL

on:
  push:
    branches: [master]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Build Frontend
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Node dependencies
        run: npm install

      - name: Update API URLs to local
        run: |
          chmod +x ./update-api-urls.sh
          ./update-api-urls.sh

      - name: Build frontend
        run: npm run build
        env:
          VITE_API_URL: "/api/v1" # Use local API path for production

      # Setup Go
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.22"

      # Build Go application for Linux (WSL) - with CGO enabled for SQLite
      - name: Build Go application
        run: |
          cd backend
          # Install SQLite development libraries
          sudo apt-get update && sudo apt-get install -y libsqlite3-dev
          # Build with CGO enabled for SQLite support
          GOOS=linux GOARCH=amd64 CGO_ENABLED=1 go build -o app
          # Verify it's a Linux binary
          file app

      # Copy frontend build to backend folder for deployment
      - name: Copy frontend to backend
        run: |
          mkdir -p backend/build
          cp -r dist/* backend/build/

      # Create start script locally in parts to avoid YAML issues
      - name: Create start script
        run: |
          echo '#!/bin/bash' > start.sh
          echo 'cd /mnt/c/wsl-app' >> start.sh
          echo 'export PORT=8080' >> start.sh
          echo 'export JWT_SECRET=test_secret' >> start.sh
          echo '' >> start.sh
          echo '# Log startup information' >> start.sh
          echo 'echo "=== App Starting at $(date) ===" > app.log' >> start.sh
          echo 'echo "Working directory: $(pwd)" >> app.log' >> start.sh
          echo 'echo "Environment:" >> app.log' >> start.sh
          echo 'env >> app.log' >> start.sh
          echo 'echo "File permissions:" >> app.log' >> start.sh
          echo 'ls -la >> app.log' >> start.sh
          echo '' >> start.sh
          echo '# Start the application' >> start.sh
          echo 'echo "Starting app..." >> app.log' >> start.sh
          echo 'nohup ./app >> app.log 2>&1 &' >> start.sh
          echo 'APP_PID=$!' >> start.sh
          echo 'echo $APP_PID > app.pid' >> start.sh
          echo 'echo "App started with PID: $APP_PID" >> app.log' >> start.sh
          echo '' >> start.sh
          echo '# Wait a moment and check if process is still running' >> start.sh
          echo 'sleep 3' >> start.sh
          echo 'if ps -p $APP_PID > /dev/null; then' >> start.sh
          echo '    echo "App is running with PID $APP_PID" >> app.log' >> start.sh
          echo 'else' >> start.sh
          echo '    echo "ERROR: App failed to start" >> app.log' >> start.sh
          echo '    echo "Exit code: $?" >> app.log' >> start.sh
          echo 'fi' >> start.sh
          chmod +x start.sh
          echo "Start script content:"
          cat start.sh

      # Create process check script
      - name: Create process check script
        run: |
          echo '#!/bin/bash' > check_process.sh
          echo 'if [ -f /mnt/c/wsl-app/app.pid ]; then' >> check_process.sh
          echo '  PID=$(cat /mnt/c/wsl-app/app.pid)' >> check_process.sh
          echo '  if ps -p "$PID" > /dev/null; then' >> check_process.sh
          echo '    echo "Process is running with PID $PID"' >> check_process.sh
          echo '  else' >> check_process.sh
          echo '    echo "Process not running (PID $PID not found)"' >> check_process.sh
          echo '  fi' >> check_process.sh
          echo 'else' >> check_process.sh
          echo '  echo "PID file not found"' >> check_process.sh
          echo 'fi' >> check_process.sh
          chmod +x check_process.sh
          echo "Check process script content:"
          cat check_process.sh

      # Install necessary tools
      - name: Install SSH tools
        run: sudo apt-get install -y openssh-client sshpass

      # Deploy to Windows server using WSL
      - name: Deploy with WSL
        run: |
          echo "Attempting WSL deployment..."
          # Create SSH directory if it doesn't exist
          mkdir -p ~/.ssh
          # Disable StrictHostKeyChecking for this deployment
          echo "StrictHostKeyChecking no" > ~/.ssh/config

          # Create app directory in WSL
          echo "Creating deployment directory in WSL..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"mkdir -p /mnt/c/wsl-app\""

          # Create deployment package
          echo "Creating deployment package..."
          tar -czf deployment.tar.gz -C backend .

          # Copy files to server
          echo "Copying files to server..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} deployment.tar.gz ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\deployment.tar.gz"

          # Copy start script to server
          echo "Copying start script..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} start.sh ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\start.sh"

          # Copy process check script
          echo "Copying process check script..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} check_process.sh ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\check_process.sh"

          # Extract files
          echo "Extracting files..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"cd /mnt/c/wsl-app && tar -xzf deployment.tar.gz\""

          # Stop any existing app with improved error handling
          echo "Stopping any existing app..."
          set +e  # Don't exit on error for this command
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"
            cd /mnt/c/wsl-app
            echo 'Checking for existing app processes...'
            
            # First, kill ALL instances of the app (not just the PID file one)
            echo 'Killing all app instances...'
            APP_PIDS=\$(pgrep -f '/mnt/c/wsl-app/app' 2>/dev/null || echo '')
            if [ -n \"\$APP_PIDS\" ]; then
              echo 'Found running app processes with PIDs: \$APP_PIDS'
              echo 'Attempting graceful shutdown of all instances...'
              pkill -TERM -f '/mnt/c/wsl-app/app'
              sleep 5
              
              # Check if any are still running
              REMAINING_PIDS=\$(pgrep -f '/mnt/c/wsl-app/app' 2>/dev/null || echo '')
              if [ -n \"\$REMAINING_PIDS\" ]; then
                echo 'Some processes still running (PIDs: \$REMAINING_PIDS), forcing kill...'
                pkill -KILL -f '/mnt/c/wsl-app/app'
                sleep 2
              fi
              
              # Final check
              FINAL_CHECK=\$(pgrep -f '/mnt/c/wsl-app/app' 2>/dev/null || echo '')
              if [ -n \"\$FINAL_CHECK\" ]; then
                echo 'ERROR: Some processes still running after force kill: \$FINAL_CHECK'
                echo 'Process details:'
                ps aux | grep -v grep | grep '/mnt/c/wsl-app/app' || echo 'No processes found in ps output'
              else
                echo 'SUCCESS: All app processes stopped'
              fi
            else
              echo 'No app processes found running'
            fi
            
            # Clean up PID file regardless
            if [ -f app.pid ]; then
              echo 'Cleaning up PID file'
              rm -f app.pid
            fi
            
            # Also kill any processes that might be using port 8080
            echo 'Checking for processes using port 8080...'
            PORT_PROCS=\$(lsof -ti:8080 2>/dev/null || echo '')
            if [ -n \"\$PORT_PROCS\" ]; then
              echo 'Found processes using port 8080: \$PORT_PROCS'
              echo 'Killing processes on port 8080...'
              kill -TERM \$PORT_PROCS 2>/dev/null || echo 'Failed to send TERM signal'
              sleep 3
              # Force kill if still there
              PORT_PROCS_AFTER=\$(lsof -ti:8080 2>/dev/null || echo '')
              if [ -n \"\$PORT_PROCS_AFTER\" ]; then
                echo 'Force killing remaining processes on port 8080...'
                kill -KILL \$PORT_PROCS_AFTER 2>/dev/null || echo 'Failed to send KILL signal'
                sleep 1
              fi
            else
              echo 'No processes found using port 8080'
            fi
            
            # Final verification
            echo 'Final verification:'
            FINAL_APP_PROCS=\$(pgrep -f '/mnt/c/wsl-app/app' 2>/dev/null || echo '')
            FINAL_PORT_PROCS=\$(lsof -ti:8080 2>/dev/null || echo '')
            
            if [ -n \"\$FINAL_APP_PROCS\" ]; then
              echo 'WARNING: App processes still running: \$FINAL_APP_PROCS'
            else
              echo 'CONFIRMED: No app processes running'
            fi
            
            if [ -n \"\$FINAL_PORT_PROCS\" ]; then
              echo 'WARNING: Port 8080 still in use by: \$FINAL_PORT_PROCS'
            else
              echo 'CONFIRMED: Port 8080 is free'
            fi
          \""
          set -e  # Resume exit on error for subsequent commands

          # Continue with remaining deployment regardless of stop result
          echo "Continuing deployment..."

          # Install required libraries - with sudo for permission issues
          echo "Installing required libraries..."
          set +e  # Don't exit on error
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'Installing libraries with sudo...' && sudo apt-get update && sudo apt-get install -y libsqlite3-0 net-tools curl\""
          set -e  # Resume exit on error

          # Make sure app is executable
          echo "Setting executable permissions..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"chmod +x /mnt/c/wsl-app/app /mnt/c/wsl-app/start.sh /mnt/c/wsl-app/check_process.sh\""

          # Start the application
          echo "Starting application..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cd /mnt/c/wsl-app && ./start.sh\""

          # Give it a moment to start up and verify multiple times
          echo "Waiting for application to start..."
          sleep 3
          
          # Enhanced startup verification with retries
          echo "Verifying application startup..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"
            cd /mnt/c/wsl-app
            
            # Check for up to 30 seconds
            for i in {1..10}; do
              echo 'Startup check attempt \$i...'
              
              # Check if PID file exists and process is running
              if [ -f app.pid ]; then
                PID=\$(cat app.pid)
                if ps -p \"\$PID\" > /dev/null; then
                  echo 'SUCCESS: Application is running with PID \$PID'
                  
                  # Also test if it's responding on the port
                  if nc -z localhost 8080; then
                    echo 'SUCCESS: Application is responding on port 8080'
                    break
                  else
                    echo 'Application process running but not responding on port 8080 yet...'
                  fi
                else
                  echo 'PID file exists but process not running'
                fi
              else
                echo 'PID file not found yet...'
              fi
              
              if [ \$i -eq 10 ]; then
                echo 'ERROR: Application failed to start properly after 30 seconds'
                echo 'Current processes:'
                ps aux | grep -v grep | grep app || echo 'No app processes found'
                echo 'Application logs:'
                tail -n 20 app.log 2>/dev/null || echo 'No logs found'
              else
                sleep 3
              fi
            done
          \""

          # Run the check process script directly (simpler approach that avoids escaping issues)
          echo "Checking if application is running..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cd /mnt/c/wsl-app && ./check_process.sh\""

          # Try checking with curl
          echo "Testing HTTP endpoint..."
          set +e
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"curl -s -o /dev/null -w '%{http_code}' http://localhost:8080/api/v1/swagger/ || echo 'Failed to connect'\""
          set -e

          # Test external endpoint
          echo "Testing external endpoint..."
          set +e
          curl -s -o /dev/null -w '%{http_code}' http://197.140.16.206:8080/api/v1/swagger/ || echo "Failed to connect to external endpoint"
          set -e

          # Display logs
          echo "Application logs:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cat /mnt/c/wsl-app/app.log 2>/dev/null || echo 'No logs found'\""

          # Display system information
          echo "System information:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"uname -a && cat /etc/os-release | grep PRETTY_NAME\""
