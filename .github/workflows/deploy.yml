name: Build and Deploy to WSL

on:
  push:
    branches: [master]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Build Frontend
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Node dependencies
        run: npm install

      - name: Update API URLs to local
        run: |
          chmod +x ./update-api-urls.sh
          ./update-api-urls.sh

      - name: Build frontend
        run: npm run build
        env:
          VITE_API_URL: "/api/v1" # Use local API path for production

      # Setup Go
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.22"
          cache-dependency-path: "backend/go.sum"

      # Build Go application for Linux (WSL) - with CGO enabled for SQLite
      - name: Build Go application
        run: |
          cd backend
          # Install SQLite development libraries
          sudo apt-get update && sudo apt-get install -y libsqlite3-dev
          # Build with CGO enabled for SQLite support
          GOOS=linux GOARCH=amd64 CGO_ENABLED=1 go build -o app
          # Verify it's a Linux binary
          file app

      # Copy frontend build to backend folder for deployment
      - name: Copy frontend to backend
        run: |
          mkdir -p backend/build
          cp -r dist/* backend/build/

      # Create start script locally in parts to avoid YAML issues
      - name: Create start script
        run: |
          echo '#!/bin/bash' > start.sh
          echo 'cd /mnt/c/wsl-app' >> start.sh
          echo 'export PORT=8080' >> start.sh
          echo 'export JWT_SECRET=test_secret' >> start.sh
          echo '' >> start.sh
          echo '# Log startup information' >> start.sh
          echo 'echo "=== App Starting at $(date) ===" > app.log' >> start.sh
          echo 'echo "Working directory: $(pwd)" >> app.log' >> start.sh
          echo 'echo "Environment:" >> app.log' >> start.sh
          echo 'env >> app.log' >> start.sh
          echo 'echo "File permissions:" >> app.log' >> start.sh
          echo 'ls -la >> app.log' >> start.sh
          echo '' >> start.sh
          echo '# Start the application' >> start.sh
          echo 'echo "Starting app..." >> app.log' >> start.sh
          echo 'nohup ./app >> app.log 2>&1 &' >> start.sh
          echo 'APP_PID=$!' >> start.sh
          echo 'echo $APP_PID > app.pid' >> start.sh
          echo 'echo "App started with PID: $APP_PID" >> app.log' >> start.sh
          echo '' >> start.sh
          echo '# Wait a moment and check if process is still running' >> start.sh
          echo 'sleep 3' >> start.sh
          echo 'if ps -p $APP_PID > /dev/null; then' >> start.sh
          echo '    echo "App is running with PID $APP_PID" >> app.log' >> start.sh
          echo 'else' >> start.sh
          echo '    echo "ERROR: App failed to start" >> app.log' >> start.sh
          echo '    echo "Exit code: $?" >> app.log' >> start.sh
          echo 'fi' >> start.sh
          chmod +x start.sh
          echo "Start script content:"
          cat start.sh

      # Create process check script
      - name: Create process check script
        run: |
          echo '#!/bin/bash' > check_process.sh
          echo 'if [ -f /mnt/c/wsl-app/app.pid ]; then' >> check_process.sh
          echo '  PID=$(cat /mnt/c/wsl-app/app.pid)' >> check_process.sh
          echo '  if ps -p "$PID" > /dev/null; then' >> check_process.sh
          echo '    echo "Process is running with PID $PID"' >> check_process.sh
          echo '  else' >> check_process.sh
          echo '    echo "Process not running (PID $PID not found)"' >> check_process.sh
          echo '  fi' >> check_process.sh
          echo 'else' >> check_process.sh
          echo '  echo "PID file not found"' >> check_process.sh
          echo 'fi' >> check_process.sh
          chmod +x check_process.sh
          echo "Check process script content:"
          cat check_process.sh

      # Install necessary tools
      - name: Install SSH tools
        run: sudo apt-get install -y openssh-client sshpass

      # Deploy to Windows server using WSL
      - name: Deploy with WSL
        run: |
          echo "Attempting WSL deployment..."
          # Create SSH directory if it doesn't exist
          mkdir -p ~/.ssh
          # Disable StrictHostKeyChecking for this deployment
          echo "StrictHostKeyChecking no" > ~/.ssh/config

          # Create app directory in WSL
          echo "Creating deployment directory in WSL..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"mkdir -p /mnt/c/wsl-app\""

          # Create deployment package
          echo "Creating deployment package..."
          tar -czf deployment.tar.gz -C backend .

          # Copy files to server
          echo "Copying files to server..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} deployment.tar.gz ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\deployment.tar.gz"

          # Copy start script to server
          echo "Copying start script..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} start.sh ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\start.sh"

          # Copy process check script
          echo "Copying process check script..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} check_process.sh ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\check_process.sh"

          # Extract files
          echo "Extracting files..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"cd /mnt/c/wsl-app && tar -xzf deployment.tar.gz\""

          # Copy stop script to server
          echo "Copying stop script..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} scripts/stop_app.sh ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\stop_app.sh"

          # Copy verification script to server
          echo "Copying verification script..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} scripts/verify_startup.sh ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\verify_startup.sh"

          # Stop any existing app
          echo "Stopping any existing app..."
          set +e  # Don't exit on error for this command
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"chmod +x /mnt/c/wsl-app/stop_app.sh && /mnt/c/wsl-app/stop_app.sh\""
          set -e  # Resume exit on error for subsequent commands

          # Continue with remaining deployment regardless of stop result
          echo "Continuing deployment..."

          # Install required libraries - with sudo for permission issues
          echo "Installing required libraries..."
          set +e  # Don't exit on error
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'Installing libraries with sudo...' && sudo apt-get update && sudo apt-get install -y libsqlite3-0 net-tools curl\""
          set -e  # Resume exit on error

          # Add delay to prevent SSH connection issues
          echo "Waiting before setting permissions..."
          sleep 2

          # Make sure app is executable and start the application
          echo "Setting permissions and starting application..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"
            chmod +x /mnt/c/wsl-app/app /mnt/c/wsl-app/start.sh /mnt/c/wsl-app/check_process.sh
            cd /mnt/c/wsl-app && ./start.sh
          \""

          # Give it a moment to start up and verify multiple times
          echo "Waiting for application to start..."
          sleep 3
          
          # Enhanced startup verification with retries
          echo "Verifying application startup..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"chmod +x /mnt/c/wsl-app/verify_startup.sh && /mnt/c/wsl-app/verify_startup.sh\""

          # Add delay to prevent SSH connection issues
          echo "Waiting before final checks..."
          sleep 2

          # Run the check process script directly and combine with other checks
          echo "Final verification and testing..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"
            echo 'Final process check:'
            cd /mnt/c/wsl-app && ./check_process.sh
            echo ''
            echo 'Testing HTTP endpoint:'
            curl -s -o /dev/null -w 'HTTP Status: %{http_code}' http://localhost:8080/api/v1/swagger/ || echo 'Failed to connect to local endpoint'
            echo ''
            echo 'Application logs (last 10 lines):'
            tail -n 10 app.log 2>/dev/null || echo 'No logs found'
            echo ''
            echo 'System info:'
            uname -a
            cat /etc/os-release | grep PRETTY_NAME
          \""

          # Test external endpoint from GitHub Actions runner
          echo "Testing external endpoint from GitHub Actions..."
          set +e
          HTTP_CODE=$(curl -s -o /dev/null -w '%{http_code}' http://197.140.16.206:8080/api/v1/swagger/ || echo "000")
          if [ "$HTTP_CODE" = "200" ]; then
            echo "SUCCESS: External endpoint is responding (HTTP $HTTP_CODE)"
          else
            echo "WARNING: External endpoint returned HTTP $HTTP_CODE or failed to connect"
          fi
          set -e

          echo "Deployment completed successfully!"
