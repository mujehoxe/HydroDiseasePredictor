name: Build and Deploy to WSL

on:
  push:
    branches: [backend]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Build Frontend
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Node dependencies
        run: npm install

      - name: Update API URLs to local
        run: |
          chmod +x ./update-api-urls.sh
          ./update-api-urls.sh

      - name: Build frontend
        run: npm run build
        env:
          VITE_API_URL: "/api/v1" # Use local API path for production

      # Setup Go
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.22"

      # Build Go application for Linux (WSL)
      - name: Build Go application
        run: |
          cd backend
          GOOS=linux GOARCH=amd64 go build -o app
          file app  # Verify it's a Linux binary
          ls -la app  # Check the binary size and permissions

      # Copy frontend build to backend folder for deployment
      - name: Copy frontend to backend
        run: |
          mkdir -p backend/build
          cp -r dist/* backend/build/
          ls -la backend/build  # Verify the copy

      # Install necessary tools
      - name: Install SSH tools
        run: sudo apt-get install -y openssh-client sshpass

      # Deploy to Windows server using WSL
      - name: Deploy with WSL
        run: |
          echo "Attempting WSL deployment..."
          # Create SSH directory if it doesn't exist
          mkdir -p ~/.ssh
          # Disable StrictHostKeyChecking for this deployment
          echo "StrictHostKeyChecking no" > ~/.ssh/config

          # Check if WSL is installed
          echo "Checking WSL on server..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "powershell -Command \"if (!(Get-Command wsl -ErrorAction SilentlyContinue)) { Write-Error 'WSL not found, please install WSL on the Windows server'; exit 1 }\""

          # Create app directory in WSL (directly using root user for simplicity)
          echo "Creating deployment directory in WSL..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"mkdir -p /mnt/c/wsl-app\""

          # Copy build files to the server using SCP
          echo "Copying files to server..."
          # Create a deployment package
          tar -czf deployment.tar.gz -C backend . -C ../dist .
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} deployment.tar.gz ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\deployment.tar.gz"

          # Extract files in WSL
          echo "Extracting files in WSL..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"cd /mnt/c/wsl-app && tar -xzf deployment.tar.gz\""

          # List the extracted files to verify contents
          echo "Listing extracted files..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"ls -la /mnt/c/wsl-app\""

          # Check if app binary exists
          echo "Verifying app binary..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"if [ -f /mnt/c/wsl-app/app ]; then echo 'App binary exists'; else echo 'App binary NOT found!'; fi\""

          # Set executable permission on the app binary
          echo "Setting permissions..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"chmod +x /mnt/c/wsl-app/app\""

          # Stop any existing application process
          echo "Stopping existing application..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"pkill app || echo No process to kill\""

          # Run file command to verify executable format
          echo "Checking binary format..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"file /mnt/c/wsl-app/app || echo 'File command not available'\""

          # Start the application directly with debug output and absolute paths
          echo "Starting application..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"echo 'Starting app in directory: \$(pwd)' > /mnt/c/wsl-app/app.log 2>&1 && echo 'Executable permissions: \$(ls -la /mnt/c/wsl-app/app)' >> /mnt/c/wsl-app/app.log 2>&1 && cd /mnt/c/wsl-app && PORT=8080 JWT_SECRET=your_secret_here /mnt/c/wsl-app/app >> /mnt/c/wsl-app/app.log 2>&1 &\""

          # Wait a moment for the application to start
          echo "Waiting for application to start..."
          sleep 5

          # Check if application is running using simpler PowerShell
          echo "Checking application status..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "powershell -Command \"try { Get-Process -Name app -ErrorAction Stop } catch { Write-Output 'WARNING: Application may not be running!' }\""

          # Check port status using simple cmd command
          echo "Checking if port 8080 is active..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "cmd /c \"netstat -an | findstr 8080\""

          # Display application logs using cmd type command
          echo "Application logs:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "cmd /c \"if exist C:\\wsl-app\\app.log type C:\\wsl-app\\app.log\""

          # Final check for debugging - directly check what happened
          echo "Direct WSL output for debugging:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"ls -la /mnt/c/wsl-app/ && echo '=== App Log Content ===' && cat /mnt/c/wsl-app/app.log 2>/dev/null || echo 'No app.log file found'\""

      # Manual instructions if all else fails
      - name: Deployment failure instructions
        if: ${{ failure() }}
        run: |
          echo "Automated deployment failed. Please check the following:"
          echo "1. Make sure WSL is installed on the Windows server"
          echo "2. Make sure the SSH credentials are set in the GitHub secrets"
          echo "3. Check if port 8080 is available on the server"
          echo "4. You can manually deploy by following these steps:"
          echo "   a. Install WSL on your Windows server if not already installed"
          echo "   b. Create directory: mkdir -p C:\wsl-app"
          echo "   c. Copy the backend files to C:\wsl-app"
          echo "   d. Using WSL, make the binary executable: wsl --exec chmod +x /mnt/c/wsl-app/app"
          echo "   e. Run with: wsl --exec bash -c \"cd /mnt/c/wsl-app && export PORT=8080 && ./app\""
