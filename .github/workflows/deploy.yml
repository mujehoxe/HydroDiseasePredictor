name: Build and Deploy to WSL

on:
  push:
    branches: [backend]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Build Frontend
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Node dependencies
        run: npm install

      - name: Update API URLs to local
        run: |
          chmod +x ./update-api-urls.sh
          ./update-api-urls.sh

      - name: Build frontend
        run: npm run build
        env:
          VITE_API_URL: "/api/v1" # Use local API path for production

      # Setup Go
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.22"

      # Build Go application for Linux (WSL) - static binary
      - name: Build Go application
        run: |
          cd backend
          # Build with CGO disabled for static binary with fewer dependencies
          GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o app
          # Verify it's a Linux binary
          file app
          # Check the binary size and permissions
          ls -la app

      # Copy frontend build to backend folder for deployment
      - name: Copy frontend to backend
        run: |
          mkdir -p backend/build
          cp -r dist/* backend/build/
          ls -la backend/build  # Verify the copy

      # Install necessary tools
      - name: Install SSH tools
        run: sudo apt-get install -y openssh-client sshpass

      # Deploy to Windows server using WSL
      - name: Deploy with WSL
        run: |
          echo "Attempting WSL deployment..."
          # Create SSH directory if it doesn't exist
          mkdir -p ~/.ssh
          # Disable StrictHostKeyChecking for this deployment
          echo "StrictHostKeyChecking no" > ~/.ssh/config

          # Check if WSL is installed
          echo "Checking WSL on server..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "powershell -Command \"if (!(Get-Command wsl -ErrorAction SilentlyContinue)) { Write-Error 'WSL not found, please install WSL on the Windows server'; exit 1 }\""

          # Create app directory in WSL (directly using root user for simplicity)
          echo "Creating deployment directory in WSL..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"mkdir -p /mnt/c/wsl-app\""

          # Copy build files to the server using SCP
          echo "Copying files to server..."
          # Create a deployment package
          tar -czf deployment.tar.gz -C backend . -C ../dist .
          sshpass -p "${{ secrets.SSH_PASSWORD }}" scp -P ${{ secrets.SSH_PORT }} deployment.tar.gz ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:"C:\\wsl-app\\deployment.tar.gz"

          # Extract files in WSL
          echo "Extracting files in WSL..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"cd /mnt/c/wsl-app && tar -xzf deployment.tar.gz\""

          # List the extracted files to verify contents
          echo "Listing extracted files..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"ls -la /mnt/c/wsl-app\""

          # Check if app binary exists
          echo "Verifying app binary..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"if [ -f /mnt/c/wsl-app/app ]; then echo 'App binary exists'; else echo 'App binary NOT found!'; fi\""

          # Set executable permission on the app binary
          echo "Setting permissions..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"chmod +x /mnt/c/wsl-app/app\""

          # Stop any existing application process
          echo "Stopping existing application..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"pkill app || echo No process to kill\""

          # Run file command to verify executable format
          echo "Checking binary format..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"file /mnt/c/wsl-app/app || echo 'File command not available'\""

          # Try running in foreground briefly to catch any startup errors
          echo "Testing app startup in foreground to capture errors..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cd /mnt/c/wsl-app && echo '=== Testing app startup ===' > /mnt/c/wsl-app/app.log && PORT=8080 JWT_SECRET=your_secret_here /mnt/c/wsl-app/app >> /mnt/c/wsl-app/app.log 2>&1 || echo \\\$? > /mnt/c/wsl-app/exit_code.txt\""

          # Check libraries needed by the binary
          echo "Checking library dependencies..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"ldd /mnt/c/wsl-app/app 2>/mnt/c/wsl-app/ldd.log || echo 'ldd failed' > /mnt/c/wsl-app/ldd.log\""

          # Display the ldd output
          echo "Library dependency output:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cat /mnt/c/wsl-app/ldd.log\""

          # Start the application in the background
          echo "Starting application in background (after diagnostics)..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"cd /mnt/c/wsl-app && PORT=8080 JWT_SECRET=your_secret_here nohup /mnt/c/wsl-app/app >> /mnt/c/wsl-app/app.log 2>&1 &\""

          # Wait a moment for the application to start
          echo "Waiting for application to start..."
          sleep 5

          # Check if application is running using simpler PowerShell
          echo "Checking application status..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "powershell -Command \"try { Get-Process -Name app -ErrorAction Stop } catch { Write-Output 'WARNING: Application may not be running!' }\""

          # Check port status using simple cmd command
          echo "Checking if port 8080 is active..."
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "cmd /c \"netstat -an | findstr 8080\""

          # Display application logs using cmd type command
          echo "Application logs:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "cmd /c \"if exist C:\\wsl-app\\app.log type C:\\wsl-app\\app.log\""

          # Final check for debugging - directly check what happened
          echo "Direct WSL output for debugging:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --exec bash -c \"ls -la /mnt/c/wsl-app/ && echo '=== App Log Content ===' && cat /mnt/c/wsl-app/app.log 2>/dev/null || echo 'No app.log file found'\""

          # Check if there's an exit code file
          echo "Checking for exit code:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"if [ -f /mnt/c/wsl-app/exit_code.txt ]; then echo 'Exit code:' && cat /mnt/c/wsl-app/exit_code.txt; else echo 'No exit code file found'; fi\""

          # Try to identify what might be wrong with WSL 1
          echo "WSL version information:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl --version || echo 'WSL version command not supported (likely WSL 1)'"

          # Check system info
          echo "System information:"
          sshpass -p "${{ secrets.SSH_PASSWORD }}" ssh -p ${{ secrets.SSH_PORT }} ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "wsl bash -c \"uname -a && cat /etc/os-release | grep PRETTY_NAME\""

      # Manual instructions if all else fails
      - name: Deployment failure instructions
        if: ${{ failure() }}
        run: |
          echo "Automated deployment failed. Please check the following:"
          echo "1. Make sure WSL is installed on the Windows server"
          echo "2. Make sure the SSH credentials are set in the GitHub secrets"
          echo "3. Check if port 8080 is available on the server"
          echo "4. You can manually deploy by following these steps:"
          echo "   a. Install WSL on your Windows server if not already installed"
          echo "   b. Create directory: mkdir -p C:\wsl-app"
          echo "   c. Copy the backend files to C:\wsl-app"
          echo "   d. Using WSL, make the binary executable: wsl --exec chmod +x /mnt/c/wsl-app/app"
          echo "   e. Run with: wsl --exec bash -c \"cd /mnt/c/wsl-app && export PORT=8080 && ./app\""
